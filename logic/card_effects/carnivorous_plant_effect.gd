# res://logic/card_effects/carnivorous_plant_effect.gd
extends SummonCardResource

const GOBLIN_SCOUT_RES_PATH = "res://data/cards/instances/goblin_scout.tres"
var goblin_scout_res: SummonCardResource = null

func _init():
	if goblin_scout_res == null:
		goblin_scout_res = load(GOBLIN_SCOUT_RES_PATH) as SummonCardResource
		if goblin_scout_res == null:
			printerr("CarnivorousPlant Error: Failed to load Goblin Scout resource at %s!" % GOBLIN_SCOUT_RES_PATH)

# _summon_instance is the Carnivorous Plant itself
func _on_arrival(_summon_instance: SummonInstance, active_combatant: Combatant, _opponent_combatant, battle_instance: Battle): # Added type for battle_instance
	var plant_instance_id: int = _summon_instance.instance_id
	var plant_card_id: String = _summon_instance.card_resource.id # "CarnivorousPlant"

	print("Carnivorous Plant (Instance: %s) arrival trigger." % plant_instance_id)
	
	if goblin_scout_res != null:
		print("...Carnivorous Plant (Instance: %s) adding Goblin Scout to %s's graveyard." % [plant_instance_id, active_combatant.combatant_name])
		
		# Create a new CardInZone for the Goblin Scout being added to the graveyard
		var new_scout_instance_id_for_graveyard: int = battle_instance._generate_new_card_instance_id()
		var scout_card_in_zone: CardInZone = CardInZone.new(goblin_scout_res, new_scout_instance_id_for_graveyard)
		
		# Call add_card_to_graveyard with the CardInZone.
		# The from_zone is conceptual ("created by effect").
		# The p_instance_id_if_relevant for add_card_to_graveyard refers to the ID the card had
		# in its 'from_zone'. Since this scout is new/from limbo, its own new ID is relevant.
		var from_zone_reason = "created_by_effect_" + plant_card_id
		active_combatant.add_card_to_graveyard(scout_card_in_zone, from_zone_reason, new_scout_instance_id_for_graveyard)
		# The card_moved event inside add_card_to_graveyard will use new_scout_instance_id_for_graveyard as its main instance_id
		# and will have to_details.instance_id also as new_scout_instance_id_for_graveyard.
		# We should also ensure that card_moved event gets sourced to the Plant.
		# This means add_card_to_graveyard needs to take source_card_id and source_instance_id of the *effect causing the addition*.

		# To properly source the card_moved event generated by add_card_to_graveyard
		# TO THE CARNIVOROUS PLANT, we would need to pass plant_card_id and plant_instance_id
		# into add_card_to_graveyard. Let's assume add_card_to_graveyard gets an update for this.
		# For now, the current call to add_card_to_graveyard will only source the move to the scout itself.

		# Optional: a visual effect specific to the Plant's action
		battle_instance.add_event({
			"event_type": "visual_effect",
			"effect_id": "carnivorous_plant_summons_scout_to_grave",
			"instance_id": plant_instance_id, # The Plant is the source/subject of this visual
			"target_locations": [active_combatant.combatant_name + " graveyard"],
			"details": {"added_card_id": goblin_scout_res.id, "added_instance_id": new_scout_instance_id_for_graveyard},
			"source_card_id": plant_card_id,
			"source_instance_id": plant_instance_id
		})
	else:
		printerr("Carnivorous Plant (Instance: %s) cannot add Scout to grave: Goblin Scout resource not loaded." % plant_instance_id)
		battle_instance.add_event({
			"event_type": "log_message",
			"message": "Carnivorous Plant (Instance: %s) failed to add Scout to graveyard (resource not loaded)." % plant_instance_id,
			"source_card_id": plant_card_id,
			"source_instance_id": plant_instance_id
		})
